<html>

<body>
</body>

</html>

<script>
    function track(target, key) {
        if (!activeEffect) return
        let depsMap = bucket.get(target)
        if (!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }
        let deps = depsMap.get(key)
        if (!deps) {
            depsMap.set(key, (deps = new Set()))
        }
        deps.add(activeEffect)
        activeEffect.deps.push(deps)
    }

    function trigger(target, key) {
        const depsMap = bucket.get(target)
        if (!depsMap) return
        const effects = depsMap.get(key)

        const effectsToRun = new Set()
        effects && effects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
        effectsToRun.forEach(effectFn => {
            if (effectFn.options.scheduler) {
                effectFn.options.scheduler(effectFn)
            } else {
                effectFn()
            }
        })
    }

    let activeEffect
    const effectStack = []
    function effect(fn, options = {}) {
        const effectFn = () => {
            cleanup(effectFn)
            activeEffect = effectFn
            effectStack.push(effectFn)
            const res = fn()
            effectStack.pop()
            activeEffect = effectStack[effectStack.length - 1]
            return res
        }
        effectFn.options = options
        effectFn.deps = []
        if (!options.lazy) {
            effectFn()
        }
        return effectFn
    }



    function cleanup(effectFn) {
        for (let i = 0; i < effectFn.deps.length; i++) {
            const deps = effectFn.deps[i]
            deps.delete(effectFn)
        }
        effectFn.deps.length = 0
    }

    const bucket = new WeakMap()






    // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数
    function watch(source, cb) {
        // 定义 getter
        let getter
        // 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋s值给 getter
        if (typeof source === 'function') {
            getter = source
        } else {
            // 否则按照原来的实现调用 traverse 递归地读取
            // 触发读取操作，从而建立联系
            getter = () => traverse(source)
        }
        // 定义旧值与新值
        let oldValue, newValue

        // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到effectFn 中以便后续手动调用
        const effectFn = effect(
            // 执行 getter
            () => getter(),
            {
                lazy: true,
                scheduler() {
                    // 在 scheduler 中重新执行副作用函数，得到的是新值
                    newValue = effectFn()
                    // 将旧值和新值作为回调函数的参数
                    cb(oldValue, newValue) // 当数据变化时，调用回调函数 cb
                    // 更新旧值，不然下一次会得到错误的旧值
                    oldValue = newValue
                }
            }
        )
        // 手动调用副作用函数，拿到的值就是旧值
        oldValue = effectFn()
    }

    function traverse(value, seen = new Set()) {
        // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做
        if (typeof value !== 'object' || value === null ||
            seen.has(value)) return
        // 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环
        seen.add(value)
        // 暂时不考虑数组等其他结构
        // 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理
        for (const k in value) {
            traverse(value[k], seen)
        }

        return value
    }


    // 示例//////////////////////////////////////////////////
    const data = {
        foo: 1,
        bar: 2
    }
    const obj = new Proxy(data, {
        get(target, p, receiver) {
            track(target, p)
            return target[p]
        },
        set(target, p, value, receiver) {
            target[p] = value
            trigger(target, p)
            return true
        }
    })


    // 此处如果watch的是整个响应式数据，则无法取得oldValue和newValue
    watch(() => obj.foo, (oldValue, newValue) => {
        console.log('watch!')
        console.log('oldValue: ', oldValue, 'newValue: ', newValue)
    })

    obj.foo++


</script>

<!-- ^\s*([0-9]+)[\.]* -->